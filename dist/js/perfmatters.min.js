// Measuring the Critical Rendering Path with Navigation Timing
// https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp
function logCRP(){"use strict";var e=window.performance.timing,t=e.domContentLoadedEventStart-e.domLoading,n=e.domComplete-e.domLoading,o=document.getElementById("crp-stats");o.textContent="DCL: "+t+"ms, onload: "+n+"ms"}window.addEventListener("load",function(){logCRP()}),/*! loadCSS: load a CSS file asynchronously. [c]2016 @scottjehl, Filament Group, Inc. Licensed MIT */
function(e){"use strict";/* exported loadCSS */
var t=function(t,n,o){
// wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
function r(e){return l.body?e():void setTimeout(function(){r(e)})}function a(){i.addEventListener&&i.removeEventListener("load",a),i.media=o||"all"}
// Arguments explained:
// `href` [REQUIRED] is the URL for your CSS file.
// `before` [OPTIONAL] is the element the script should use as a reference for injecting our stylesheet <link> before
// By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM. However, you might desire a more specific location in your document.
// `media` [OPTIONAL] is the media type or query of the stylesheet. By default it will be 'all'
var d,l=e.document,i=l.createElement("link");if(n)d=n;else{var s=(l.body||l.getElementsByTagName("head")[0]).childNodes;d=s[s.length-1]}var u=l.styleSheets;i.rel="stylesheet",i.href=t,
// temporarily set media to something inapplicable to ensure it'll fetch without blocking render
i.media="only x",
// Inject link
// Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
// Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
r(function(){d.parentNode.insertBefore(i,n?d:d.nextSibling)});
// A method (exposed on return object for external use) that mimics onload by polling until document.styleSheets until it includes the new sheet.
var c=function(e){for(var t=i.href,n=u.length;n--;)if(u[n].href===t)return e();setTimeout(function(){c(e)})};
// once loaded, set link's media back to `all` so that the stylesheet applies once it loads
return i.addEventListener&&i.addEventListener("load",a),i.onloadcssdefined=c,c(a),i};
// commonjs
"undefined"!=typeof exports?exports.loadCSS=t:e.loadCSS=t}("undefined"!=typeof global?global:this),/*! CSS rel=preload polyfill. Depends on loadCSS function. [c]2016 @scottjehl, Filament Group, Inc. Licensed MIT  */
function(e){
// rel=preload support test
if(e.loadCSS){var t=loadCSS.relpreload={};
// if link[rel=preload] is not supported, we must fetch the CSS manually using loadCSS
if(t.support=function(){try{return e.document.createElement("link").relList.supports("preload")}catch(t){return!1}},
// loop preload links and fetch using loadCSS
t.poly=function(){for(var t=e.document.getElementsByTagName("link"),n=0;n<t.length;n++){var o=t[n];"preload"===o.rel&&"style"===o.getAttribute("as")&&(e.loadCSS(o.href,o),o.rel=null)}},!t.support()){t.poly();var n=e.setInterval(t.poly,300);e.addEventListener&&e.addEventListener("load",function(){e.clearInterval(n)}),e.attachEvent&&e.attachEvent("onload",function(){e.clearInterval(n)})}}}(this);